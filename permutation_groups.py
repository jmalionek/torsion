from sage.all import PermutationGroupElement, PermutationGroup, ZZ, SymmetricGroup
from sage.all import GF, ProjectiveSpace, magma
import representation_theory


def magma_permutation_hom_to_sage(hom):
	"""
	Given a magma homomorphism from a group to a permutation group, returns a list of the images in a sage
	permutation group
	"""
	group_gens = [hom.Image(gen) for gen in hom.Domain().gens()]
	group_gens = [PermutationGroupElement(gen.Eltseq().sage()) for gen in group_gens]
	return group_gens


def permutation_action_to_PGL2(generators):
	"""
	Given a list of permutation group elements which act on P(q) the projective line on the field with q elements,
	returns the matrices representing the group elements.
	"""
	perm_group = PermutationGroup(generators)
	# print(perm_group)
	degree = perm_group.degree()
	q = degree - 1
	F = GF(q)
	PLine = ProjectiveSpace(1, F)
	gens = []

	def coords(num):
		if num <= q:
			return PLine([num_to_field(num, F), 1])
		else:
			return PLine([1, 0])
	for gen in generators:
		gen_dict = gen.dict()
		points = [coords(i) for i in [1, q, q+1]]
		mat = PLine.point_transformation_matrix(points, [coords(gen_dict[pt]) for pt in [1, q, q+1]])
		gens.append(mat)
	# for i in range(len(generators)):
	# 	print(gens[i])
	# 	print(generators[i])
	# 	print()
	return gens


def sage_group_to_PGL2_through_magma(group, n, limit=None, check=True):
	"""
		Given a sage group and an n, finds all the homomorphisms from group to PGL(2,n)
		which can be lifted to PSL(2, n)
		"""
	# old_group = group
	# iso = group.simplification_isomorphism()
	# group = iso.codomain()
	magmaG = representation_theory.get_magma_group(group)
	if limit is None:
		limit = 0
	psl, action = magma.PSL(2, n, nvals=2)
	action = action.sage()
	homs = magma.Homomorphisms(magmaG, psl, Limit=limit)
	homs = [magma_permutation_hom_to_sage(hom) for hom in homs]
	reps = []
	P1 = ProjectiveSpace(1, action[0][0].parent())
	p_action = [P1((elt[0], elt[1])) for elt in action]
	for hom in homs:
		gens = [P1.point_transformation_matrix(p_action[0:3], [p_action[gen(i + 1) - 1] for i in range(3)]) for gen in hom]
		# gens = [gen.transpose() for gen in gens]
		if check:
			representation_theory.check_pgl_rep(gens, group)
		if gens:
			reps.append(gens)
	# new_reps = [representation_theory.unsimplify_generators(rep, iso, False) for rep in reps]
	if check:
		# [representation_theory.check_pgl_rep(rep, old_group) for rep in new_reps]
		[representation_theory.check_pgl_rep(rep, group) for rep in reps]
	return reps


def sage_group_to_SL2_through_magma(group, n):
	"""
	Given a sage group and an n, finds all the homomorphisms from group to PGL(2,n)
	which can be lifted to PSL(2, n)
	"""
	reps = sage_group_to_PGL2_through_magma(group, n, False)
	for rep in reps:
		gens = representation_theory.lift_PGL2_to_PSL2(rep)
		gens = representation_theory.fast_lift_SL2_simple_representation(gens, group)
		if gens:
			reps.append(gens)
	return reps





def magma_permutation_action_to_PGL2(hom):
	"""
	Given a homomorphism to a magma permutation group representing PSL2, returns a list of matrices for the images of
	the generators of the domain of the homomorphism.
	"""
	group_gens = [hom.Image(gen) for gen in hom.Domain().gens()]
	group_gens = [PermutationGroupElement(gen.Eltseq().sage()) for gen in group_gens]
	unconj_group = PermutationGroup(group_gens)
	degree = unconj_group.degree()
	q = degree - 1
	trash, action = magma.PSL(2, q, nvals=2)
	action = action.sage()
	F = action[0][0].parent()
	assert F.order() == q
	PLine = ProjectiveSpace(F, 1)
	def inv_coords(elt):
		elt = PLine(list(elt))
		if elt[1] == 1:
			return field_to_num(elt[0], F)
		elif elt[1] == 0:
			return q+1
		else:
			print('SOMETHING WRONG')
			print(elt)
	map_dict = {i+1: inv_coords(action[i]) for i in range(q+1)}
	new_gens = []
	for gen in group_gens:
		new_gen = []
		for cycle in gen.cycle_tuples():
			new_cycle = tuple(map_dict[i] for i in cycle)
			new_gen.append(new_cycle)
		new_gens.append(PermutationGroupElement(new_gen, SymmetricGroup(degree)))

	group = PermutationGroup(new_gens)
	assert group.order() == unconj_group.order()
	# Magma has elements of PSL2 acting on the right on P^1.
	return [mat.transpose() for mat in permutation_action_to_PGL2(new_gens)]


def num_to_field(num, F):
	"""
	Given a finite field F with q elements and a number from 1 to q inclusive, deterministically returns a field element
	corresponding to that number.
	Designed to be the inverse of field_to_num
	Note: Only supports finite sagemath fields generated by a single variable
	"""
	p = F.characteristic()
	gen = F.gens()[0]
	degree = 0
	element = F.zero()
	if num >= F.order():
		num = num % F.order()
	while num > 0:
		element = element + gen**degree*(F(num % p))
		num = num//p
		degree += 1
	return element


def field_to_num(elt, F):
	"""
	Given a finite field F with q elements and an element from that field, deterministically returns a number from 1 to
	q inclusive.
	Designed to be the inverse of num_to_field
	Note: Only supports finite sagemath fields generated by a single variable
	"""
	if F.degree() > 1:
		if elt.integer_representation() == 0:
			return F.order()
		else:
			return elt.integer_representation()
	else:
		if elt == F.zero():
			return F.order()
		else:
			return ZZ(elt)
