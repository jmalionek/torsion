from sage.all import PermutationGroupElement, PermutationGroup, ZZ, SymmetricGroup
from sage.all import GF, ProjectiveSpace, magma
import representation_theory


def magma_permutation_hom_to_sage(hom):
	"""
	Given a magma homomorphism from a group to a permutation group, returns a list of the images in a sage
	permutation group
	"""
	group_gens = [hom.Image(gen) for gen in hom.Domain().gens()]
	group_gens = [PermutationGroupElement(gen.Eltseq().sage()) for gen in group_gens]
	return group_gens


def permutation_action_to_PGL2(generators):
	"""
	Given a list of permutation group elements which act on P(q) the projective line on the field with q elements,
	returns the matrices representing the group elements.
	"""
	perm_group = PermutationGroup(generators)
	# print(perm_group)
	degree = perm_group.degree()
	q = degree - 1
	F = GF(q)
	PLine = ProjectiveSpace(1, F)
	gens = []

	def coords(num):
		if num <= q:
			return PLine([num_to_field(num, F), 1])
		else:
			return PLine([1, 0])
	for gen in generators:
		gen_dict = gen.dict()
		points = [coords(i) for i in [1, q, q+1]]
		mat = PLine.point_transformation_matrix(points, [coords(gen_dict[pt]) for pt in [1, q, q+1]])
		gens.append(mat)
	# for i in range(len(generators)):
	# 	print(gens[i])
	# 	print(generators[i])
	# 	print()
	return gens


def magma_permutation_action_to_PGL2(hom):
	"""
	Given a homomorphism to a magma permutation group representing PSL2, returns a list of matrices for the images of
	the generators of the domain of the homomorphism.
	"""
	group_gens = [hom.Image(gen) for gen in hom.Domain().gens()]
	group_gens = [PermutationGroupElement(gen.Eltseq().sage()) for gen in group_gens]
	unconj_group = PermutationGroup(group_gens)
	degree = unconj_group.degree()
	q = degree - 1
	trash, action = magma.PSL(2, q, nvals=2)
	action = action.sage()
	F = action[0][0].parent()
	assert F.order() == q
	PLine = ProjectiveSpace(F, 1)

	def inv_coords(elt):
		elt = PLine(list(elt))
		if elt[1] == 1:
			return field_to_num(elt[0], F)
		elif elt[1] == 0:
			return q+1
		else:
			print('SOMETHING WRONG')
			print(elt)
	map_dict = {i+1: inv_coords(action[i]) for i in range(q+1)}
	new_gens = []
	for gen in group_gens:
		new_gen = []
		for cycle in gen.cycle_tuples():
			new_cycle = tuple(map_dict[i] for i in cycle)
			new_gen.append(new_cycle)
		new_gens.append(PermutationGroupElement(new_gen, SymmetricGroup(degree)))

	group = PermutationGroup(new_gens)
	assert group.order() == unconj_group.order()
	# Magma has elements of PSL2 acting on the right on P^1.
	return [mat.transpose() for mat in permutation_action_to_PGL2(new_gens)]


def num_to_field(num, F):
	"""
	Given a finite field F with q elements and a number from 1 to q inclusive, deterministically returns a field element
	corresponding to that number.
	Designed to be the inverse of field_to_num
	Note: Only supports finite sagemath fields generated by a single variable
	"""
	p = F.characteristic()
	gen = F.gens()[0]
	degree = 0
	element = F.zero()
	if num >= F.order():
		num = num % F.order()
	while num > 0:
		element = element + gen**degree*(F(num % p))
		num = num//p
		degree += 1
	return element


def field_to_num(elt, F):
	"""
	Given a finite field F with q elements and an element from that field, deterministically returns a number from 1 to
	q inclusive.
	Designed to be the inverse of num_to_field
	Note: Only supports finite sagemath fields generated by a single variable
	"""
	if F.degree() > 1:
		if elt.integer_representation() == 0:
			return F.order()
		else:
			return elt.integer_representation()
	else:
		if elt == F.zero():
			return F.order()
		else:
			return ZZ(elt)
